<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>t-online Neon Glitch (Endlosschleife)</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #1a1a1a; 
    overflow: hidden; 
    font-family: 'Arial', sans-serif;
  }

  .logo {
    font-size: 6em; 
    color: #fff; 
    display: flex;
    perspective: 800px; 
    position: relative;
    user-select: none; 
  }

  .logo span {
    display: inline-block;
    position: relative;
    
    /* Neon-Effekt (Basis) */
    text-shadow: 0 0 5px rgba(226, 0, 116, 0.7),
                 0 0 10px rgba(226, 0, 116, 0.5),
                 0 0 20px rgba(226, 0, 116, 0.3);
    color: #e20074; 

    /* * CSS-INITIALZUSTAND (wichtig für die Schleife)
     * Hierhin kehrt das Element zurück, wenn alle Animationsklassen entfernt sind.
     */
    opacity: 0;
    transform: translateZ(-200px) translateY(100px) rotateX(90deg) scale(0.5);
  }

  /* --- Keyframes für Animationen --- */

  /* 1. Explosions-Eintritt */
  .explode-in {
    /* 'forwards' hält den Endzustand (sichtbar) */
    animation: explodeIn 1.2s forwards cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  @keyframes explodeIn {
    0% {
      opacity: 0;
      transform: translateZ(-200px) translateY(100px) rotateX(90deg) scale(0.5);
    }
    50% {
      opacity: 1;
      transform: translateZ(0) translateY(-10px) rotateX(0deg) scale(1.1); 
    }
    100% {
      opacity: 1;
      transform: translateZ(0) translateY(0) rotateX(0deg) scale(1);
    }
  }

  /* 2. Neon-Pulsieren */
  .neon-pulse {
    animation: neonPulse 2s infinite alternate ease-in-out;
  }

  @keyframes neonPulse {
    0% {
      text-shadow: 0 0 5px rgba(226, 0, 116, 0.7),
                   0 0 10px rgba(226, 0, 116, 0.5),
                   0 0 20px rgba(226, 0, 116, 0.3),
                   0 0 40px rgba(226, 0, 116, 0.1);
      color: #e20074;
    }
    100% {
      text-shadow: 0 0 8px rgba(255, 100, 200, 0.9), 
                   0 0 15px rgba(255, 100, 200, 0.7),
                   0 0 30px rgba(255, 100, 200, 0.5),
                   0 0 60px rgba(255, 100, 200, 0.2);
      color: #ff64c8; 
    }
  }

  /* 3. Glitch-Effekt (zufällig) */
  .glitch {
    animation: glitchEffect 0.2s steps(2, end) forwards;
  }

  @keyframes glitchEffect {
    /* ... (unverändert von oben) ... */
    0% {
      transform: translateX(0);
      text-shadow: 0 0 5px rgba(226, 0, 116, 0.7);
    }
    33% {
      transform: translateX(3px) skewX(20deg); 
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8), 
                   -2px 0 0 rgba(255, 0, 200, 0.6); 
      color: #00c8ff;
    }
    66% {
      transform: translateX(-3px) skewX(-20deg); 
      text-shadow: 0 0 10px rgba(255, 0, 200, 0.8), 
                   2px 0 0 rgba(0, 200, 255, 0.6); 
      color: #ff00c8;
    }
    100% {
      transform: translateX(0);
      text-shadow: 0 0 5px rgba(226, 0, 116, 0.7);
    }
  }

  /* 4. Hover-Effekt (unverändert) */
  .logo:hover span {
    transform: translateY(-5px) scale(1.05);
    transition: transform 0.2s ease-out; 
  }
  .logo:hover span:nth-child(even) { 
    transform: translateY(5px) scale(1.05);
  }

  /* * 5. NEU: Explosions-Austritt (Umkehrung von 1.) 
   */
  .explode-out {
    /* 'forwards' hält den Endzustand (unsichtbar) */
    animation: explodeOut 0.8s forwards cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  @keyframes explodeOut {
    0% {
      opacity: 1;
      transform: translateZ(0) translateY(0) rotateX(0deg) scale(1);
    }
    50% {
      opacity: 1;
      transform: translateZ(0) translateY(-10px) rotateX(0deg) scale(1.1); /* Kleines Aufbäumen */
    }
    100% {
      /* Zurück zum CSS-Initialzustand */
      opacity: 0;
      transform: translateZ(-200px) translateY(100px) rotateX(90deg) scale(0.5);
    }
  }

</style>
</head>
<body>

<div class="logo">
  <span>t</span>
  <span>-</span>
  <span>o</span>
  <span>n</span>
  <span>l</span>
  <span>i</span>
  <span>n</span>
  <span>e</span>
</div>

<script>
  const letters = document.querySelectorAll('.logo span');

  /**
   * Führt eine Animation auf einer Gruppe von Elementen nacheinander (gestaffelt) aus.
   * Gibt ein Promise zurück, das auflöst, wenn die LETZTE Animation beendet ist.
   * NEU: 'removeClass' Flag, um zu steuern, ob die Klasse nach der Animation entfernt wird.
   */
  function runStaggeredAnimation(elements, className, staggerDelay = 100, removeClass = true) {
    return new Promise((resolve) => {
      let completedCount = 0;
      const totalElements = elements.length;

      if (totalElements === 0) { 
        resolve();
        return;
      }

      elements.forEach((el, index) => {
        setTimeout(() => {
          el.classList.add(className);

          const handler = (e) => {
            // Sicherstellen, dass wir auf die richtige Animation hören
            if (e.animationName === e.currentTarget.style.animationName || elements.length === 1 || e.animationName === className.replace('.','')) {
               
                if (removeClass) { // Nur entfernen, wenn Flag gesetzt ist
                    el.classList.remove(className);
                }
                el.removeEventListener('animationend', handler);
                
                completedCount++;
                if (completedCount === totalElements) {
                    resolve();
                }
            }
             // Fallback für Keyframe-Namen
             if (e.animationName === 'explodeIn' || e.animationName === 'explodeOut') {
                if (removeClass) { el.classList.remove(className); }
                el.removeEventListener('animationend', handler);
                completedCount++;
                if (completedCount === totalElements) { resolve(); }
             }
          };
          
          // Wir verwenden 'animationend' als primären Listener
           el.addEventListener('animationend', handler, { once: true });

        }, index * staggerDelay);
      });
    });
  }

  /**
   * Eine einfache Wartefunktion (Promise-basiertes setTimeout)
   */
  function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }


  // --- HAUPTSTEUERUNG (mit async/await und while(true)) ---

  async function startAnimationChain() {
    
    // Zufälliger Glitch-Effekt (startet einmal und läuft ewig im Hintergrund)
    setInterval(() => {
      // Nur glitchen, wenn die Buchstaben sichtbar sind (also 'explode-in' haben)
      if (letters[0].classList.contains('explode-in')) {
        const randomLetter = letters[Math.floor(Math.random() * letters.length)];
        randomLetter.classList.add('glitch');

        const glitchHandler = (e) => {
          if (e.animationName === 'glitchEffect') {
            randomLetter.classList.remove('glitch');
            randomLetter.removeEventListener('animationend', glitchHandler);
          }
        };
        randomLetter.addEventListener('animationend', glitchHandler, { once: true });
      }
    }, 1500 + Math.random() * 2000); // Glitch alle 1.5 bis 3.5 Sekunden


    // --- Die Endlosschleife ---
    while (true) {
      
      // 1. Explosions-Eintritt
      // 'false' = Klasse nicht entfernen, da 'forwards' den Zustand halten soll
      await runStaggeredAnimation(letters, 'explode-in', 80, false);

      // 2. Neon-Pulsieren starten
      letters.forEach(letter => {
        letter.classList.add('neon-pulse');
      });

      // 3. Warten, während die Animation sichtbar ist
      await wait(5000); // 5 Sekunden anzeigen

      // 4. Neon-Pulsieren stoppen
      letters.forEach(letter => {
        letter.classList.remove('neon-pulse');
      });
      await wait(200); // Kurze Atempause

      // 5. Explosions-Austritt
      // 'false' = Klasse nicht entfernen, 'forwards' hält den unsichtbaren Zustand
      await runStaggeredAnimation(letters, 'explode-out', 50, false);

      // 6. WICHTIG: Reset für den nächsten Loop
      // Wir warten kurz und entfernen dann die 'forwards'-Animationsklassen.
      // Dadurch fallen die Elemente in ihren CSS-Initialzustand (opacity: 0, transform: ...) zurück.
      await wait(500); 
      letters.forEach(letter => {
        letter.classList.remove('explode-in', 'explode-out');
      });

      // 7. Pause vor dem Neustart der Schleife
      await wait(1500); 
    }
  }

  // Animation starten!
  document.addEventListener('DOMContentLoaded', startAnimationChain);
</script>

</body>
</html>